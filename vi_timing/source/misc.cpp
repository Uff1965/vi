// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

/********************************************************************\
'vi_timing' is a compact library designed for measuring the execution time of
code in C and C++.

Copyright (C) 2024 A.Prograamar

This library was developed for experimental and educational purposes.
Please temper your expectations accordingly. If you encounter any bugs or have
suggestions for improvements, kindly contact me at programmer.amateur@proton.me.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. 
If not, see <https://www.gnu.org/licenses/gpl-3.0.html#license-text>.
\********************************************************************/

#include "misc.h"

#include "build_number_maker.h"
#include "../vi_timing.h"

#ifdef _WIN32
#	include <Windows.h> // SetThreadAffinityMask
#	include <processthreadsapi.h> // GetCurrentProcessorNumber
#elif defined (__linux__)
#	include <pthread.h> // For pthread_setaffinity_np.
#	include <sched.h> // For sched_getcpu.
#endif

#include <array>
#include <atomic>
#include <cassert>
#include <chrono>
#include <cmath>
#include <iomanip>
#include <sstream>
#include <string_view>
#include <thread>
#include <vector>

namespace ch = std::chrono;
using namespace std::chrono_literals;

namespace
{
#ifdef NDEBUG
	constexpr char CONFIG[] = "Release";
#else
	constexpr char CONFIG[] = "Debug";
#endif
#ifdef VI_TM_SHARED
	constexpr char TYPE[] = "shared";
#else
	constexpr char TYPE[] = "static";
#endif

	class affinity_fix_t
	{
#if defined(_WIN32)
		DWORD_PTR previous_affinity_{};
#elif defined(__linux__)
		cpu_set_t previous_affinity_{};
#endif
		std::size_t cnt_ = 0U;
		static thread_local affinity_fix_t s_affinity;
		~affinity_fix_t() { assert(0 == cnt_); }
	public:
		static void fixate();
		static void restore();
	};

	thread_local affinity_fix_t affinity_fix_t::s_affinity;

	void affinity_fix_t::fixate()
	{
		if (0 != s_affinity.cnt_++)
		{	return;
		}

#if defined(_WIN32)
		const auto core_id = GetCurrentProcessorNumber();
		const auto affinity = static_cast<DWORD_PTR>(1U) << core_id;
		const auto thread = GetCurrentThread();
		if( (s_affinity.previous_affinity_ = SetThreadAffinityMask(thread, affinity)) != 0)
		{	return; // Ok!
		}
#elif defined(__linux__)
		const auto thread = pthread_self();
		if (0 == pthread_getaffinity_np(thread, sizeof(s_affinity.previous_affinity_), &s_affinity.previous_affinity_))
		{	if (const auto core_id = sched_getcpu(); core_id >= 0)
			{	cpu_set_t affinity;
				CPU_ZERO(&affinity);
				CPU_SET(core_id, &affinity);
				if (0 == pthread_setaffinity_np(thread, sizeof(affinity), &affinity))
				{	return; // Ok!
				}
			}
		}
#endif
		assert(false);
		return; // Fail!
	}

	void affinity_fix_t::restore()
	{	assert(s_affinity.cnt_ > 0);
		if (0 == --s_affinity.cnt_)
		{
#if defined(_WIN32)
			if (s_affinity.previous_affinity_ != 0)
			{	const auto thread = GetCurrentThread();
				[[maybe_unused]] const auto ret = SetThreadAffinityMask(thread, s_affinity.previous_affinity_);
				assert(ret != 0);
			}
#elif defined(__linux__)
			static const cpu_set_t affinity_zero{};
			if (!CPU_EQUAL(&s_affinity.previous_affinity_, &affinity_zero))
			{	const auto thread = pthread_self();
				const auto ret = pthread_setaffinity_np(thread, sizeof(s_affinity.previous_affinity_), &s_affinity.previous_affinity_);
				assert(0 == ret);
			}
#endif
		}
	}

	// function time_stamp converts date and time strings into a single unsigned integer representing the timestamp in the format YYMMDDhhmm.
	constexpr unsigned time_stamp(const char (&date)[12], const char (&time)[9])
	{	assert(0 == date[11] && 0 == time[8]);
		// "__DATE__ <...> a character string literal of the form 'Mmm dd yyyy'" [15.11 Predefined macro names ISO/IEC JTC1 SC22 WG21 N4860]
		enum { M1 = 0, M2, M3, D1 = 4, D2, Y3 = 9, Y4}; //__DATE__ "Mmm dd yyyy"
		// "__TIME__ <...> a character string literal of the form 'hh:mm:ss' as in the time generated by the asctime function."
		enum { h1 = 0, h2, m1 = 3, m2, s1 = 6, s2}; //__TIME__ "hh:mm:ss"
		auto c2d = [](char c) { return c == ' ' ? 0 : c - '0'; };
		auto date_c = [c2d, date](std::size_t n) { return c2d(date[n]); };
		auto time_c = [c2d, time](std::size_t n) { return c2d(time[n]); };

		const unsigned year = date_c(Y3) * 10 + date_c(Y4);
		const unsigned month = [](const char *date)
			{	// 7.27.3.1 The asctime function. [C17 ballot ISO/IEC 9899:2017]
				constexpr std::array<std::string_view, 13> mon_names{"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
				auto n = mon_names.size();
				while (--n && std::string_view{ date, 3 } != mon_names[n])
				{/**/}
				return static_cast<unsigned>(n);
			}(date);
		const unsigned day = date_c(D1) * 10 + date_c(D2);
		const unsigned hour = time_c(h1) * 10 + time_c(h2);
		const unsigned minute = time_c(m1) * 10 + time_c(m2);

		return(100 * (100 * (100 * (100 * (year) + month) + day) + hour) + minute);
	}

	unsigned build_number = 0U; // build_number is initialized by the compilation time of the last unit of translation in the YYMMDDhhmm format.

	[[nodiscard]] double round_ext(double num, unsigned char significant)
	{	assert(significant > 0);
		if (0 == significant || std::isnan(num) || std::isinf(num) || 0.0 == num)
			return num;

		const auto exp = std::ceil(std::log10(std::abs(num)));
		const auto factor = std::pow(10.0, significant - exp);
		return std::round(num * factor) / factor;
	}
} // namespace

/// <summary>
/// Converts a duration to a string representation with specified precision and decimal places.
/// </summary>
/// <param name="sec">The duration to be converted.</param>
/// <param name="significant">The number of significant digits to round to.</param>
/// <param name="decimal">The number of decimal places to display.</param>
/// <returns>A string representation of the duration.</returns>
/// <remarks>
/// This function handles special cases such as NaN, infinity values.
/// It rounds the duration to the specified precision and formats it with the appropriate unit suffix.
/// </remarks>
[[nodiscard]] std::string misc::to_string(const ch::duration<double> &sec, unsigned char significant, unsigned char decimal)
{	assert(decimal < significant);

	std::string result;
	
	if (auto num = sec.count(); std::isnan(num))
	{	result = "NaN";
	}
	else if (std::isinf(num))
	{	result = (num > .0) ? "INF" : "-INF";
	}
	else
	{	num = round_ext(num, significant);

		struct
		{	std::string_view suffix_;
			double factor_;
		} unit = { " ps", 1e12 };

		if (std::abs(num) < 1e-12)
		{	num = 0.0;
		}
		else
		{	constexpr auto GROUP = 3;
			const auto supp = ((significant - decimal - 1) / GROUP) * GROUP - log10(std::abs(num));
			if (supp <= -6) { unit = { " Ms", 1e-6 }; }
			else if (supp <= -3) { unit = { " ks", 1e-3 }; }
			else if (supp <= 0) { unit = { " s ", 1e+0 }; }
			else if (supp <= 3) { unit = { " ms", 1e+3 }; }
			else if (supp <= 6) { unit = { " us", 1e+6 }; }
			else if (supp <= 9) { unit = { " ns", 1e+9 }; }
		}

		std::ostringstream ss;
		ss << std::fixed << std::setprecision(decimal) << (num * unit.factor_) << unit.suffix_;
		result = ss.str();
	}

	return result;
}



unsigned misc::build_number_updater(const char (&date)[12], const char (&time)[9])
{	build_number = std::max(time_stamp(date, time), build_number);
	return build_number;
}

void VI_TM_CALL vi_tmThreadAffinityFixate()
{	affinity_fix_t::fixate();
}

void VI_TM_CALL vi_tmThreadAffinityRestore()
{	affinity_fix_t::restore();
}

void VI_TM_CALL vi_tmThreadYield(void)
{	std::this_thread::yield();
}

void VI_TM_CALL vi_tmWarming(unsigned int threads_qty, unsigned int ms)
{
	if (0 == ms)
	{	return;
	}

	if(const auto cores_qty = std::max(1U, std::thread::hardware_concurrency()); 0 == threads_qty || cores_qty < threads_qty)
	{	threads_qty = cores_qty;
	}

	static auto load_dummy = []
		{	volatile auto _ = 0.0;
			for (auto n = 100'000U; n; --n)
			{	_ = _ + std::sin(n) * std::cos(n);
			}
		};

	std::atomic_bool done = false;
	auto thread_func = [&done]
		{	while (!done) //-V776 "Potentially infinite loop."
			{	load_dummy();
			}
		};

	std::vector<std::thread> additional_threads(threads_qty - 1); // Additional threads
	for (auto &t : additional_threads)
	{	t = std::thread{ thread_func };
	}

	for (const auto stop = ch::steady_clock::now() + ch::milliseconds{ ms }; ch::steady_clock::now() < stop;)
	{	load_dummy();
	}

	done = true;

	for (auto &t : additional_threads)
	{	if (t.joinable())
		{	t.join();
		}
	}
}

std::uintptr_t VI_TM_CALL vi_tmInfo(vi_tmInfo_e info)
{	std::uintptr_t result = 0U;
	switch (info)
	{
		case VI_TM_INFO_VER:
		{	result = (((VI_TM_VERSION_MAJOR) * 1000U + (VI_TM_VERSION_MINOR)) * 10000U + (VI_TM_VERSION_PATCH));
		} break;

		case VI_TM_INFO_BUILDNUMBER:
		{	result = build_number; //-V101 "Implicit assignment type conversion to memsize type."
		} break;

		case VI_TM_INFO_VERSION:
		{	static const auto version = []
				{	static_assert(VI_TM_VERSION_MAJOR <= 99 && VI_TM_VERSION_MINOR <= 999 && VI_TM_VERSION_PATCH <= 9999); //-V590 "Possible excessive expression or typo."
					std::array<char, std::size("99.999.9999.YYMMDDHHmmC ") - 1 + std::size(TYPE) - 1 + 1> res; //-V1065
					[[maybe_unused]] const auto sz = snprintf
						(	res.data(),
							res.size(),
							VI_STR(VI_TM_VERSION_MAJOR) "." VI_STR(VI_TM_VERSION_MINOR) "." VI_STR(VI_TM_VERSION_PATCH) ".%u%c %s",
							build_number,
							CONFIG[0],
							TYPE
						);
					assert(0 < sz && sz < static_cast<int>(res.size()));
					return res;
				}();
			result = reinterpret_cast<std::uintptr_t>(version.data());
		} break;

		case VI_TM_INFO_BUILDTYPE:
		{	result = reinterpret_cast<std::uintptr_t>(CONFIG);
		} break;

		case VI_TM_INFO_RESOLUTION: // double - Clock resolution [ticks]
		{	static const double resolution = misc::properties_t::props().clock_resolution_;
			result = reinterpret_cast<std::uintptr_t>(&resolution);
		} break;

		case VI_TM_INFO_DURATION: // double - Measure duration [sec]
		{	static const double duration = misc::properties_t::props().all_latency_.count();
			result = reinterpret_cast<std::uintptr_t>(&duration);
		} break;

		case VI_TM_INFO_OVERHEAD: // double - Clock duration [ticks]
		{	static const double overhead = misc::properties_t::props().clock_latency_;
			result = reinterpret_cast<std::uintptr_t>(&overhead);
		} break;

		case VI_TM_INFO_UNIT: // double - Clock duration [sec]
		{	static const double unit = misc::properties_t::props().seconds_per_tick_.count();
			result = reinterpret_cast<std::uintptr_t>(&unit);
		} break;

		default:
		{	assert(false);
		} break;
	}
	return result;
}

#ifndef NDEBUG
namespace
{
	const auto nanotests = []
	{
		{	// nanotest for round_ext
			assert(0.0 == round_ext(0.00, 1));

			assert(1.0 == round_ext(0.95, 1));
			assert(1.0 == round_ext(1.00, 1));
			assert(1.0 == round_ext(1.40, 1));
			assert(-1.0 == round_ext(-0.95, 1));
			assert(-1.0 == round_ext(-1.00, 1));
			assert(-1.0 == round_ext(-1.40, 1));

			assert(0.10 == round_ext(.0995, 2));
			assert(0.10 == round_ext(.1000, 2));
			assert(0.10 == round_ext(.1044, 2));
			assert(-0.10 == round_ext(-.0995, 2));
			assert(-0.10 == round_ext(-.1000, 2));
			assert(-0.10 == round_ext(-.1044, 2));

			assert(1.0e-16 == round_ext(0.95e-16, 1));
			assert(1.0e-16 == round_ext(1.00e-16, 1));
			assert(1.0e-16 == round_ext(1.40e-16, 1));
		}

		{	// nanotest for misc::to_string(std::chrono::duration<double> d, unsigned char precision, unsigned char dec)
			const struct
			{
				int line_;
				double num_;
				std::string_view expected_;
				unsigned char significant_;
				unsigned char decimal_;
			} tests_set[] =
			{
				{ __LINE__, .0, "0 ps", 1, 0 },
				{ __LINE__, .0, "0.00 ps", 7, 2 },
				{ __LINE__, -9e-13, "0.00 ps", 7, 2 },
				{ __LINE__, 9e-13, "0 ps", 1, 0 },
				{ __LINE__, -1e-12, "-1 ps", 1, 0 },
				{ __LINE__, 1e-12, "1 ps", 1, 0 },
				{ __LINE__, 1e-12, "1.00 ps", 7, 2 },
				{ __LINE__, -1e9, "-1000 Ms", 1, 0 },
				{ __LINE__, 1e9, "1000 Ms", 1, 0 },
				{ __LINE__, 1e9, "1000.00 Ms", 7, 2 },

				{ __LINE__, .00555555555,        "6 ms", 1, 0 },
				{ __LINE__, .05555555555,       "60 ms", 1, 0 },
				{ __LINE__, .55555555555,      "600 ms", 1, 0 },
				{ __LINE__, 5.5555555555,        "6 s ", 1, 0 },
				{ __LINE__, 55.555555555,       "60 s ", 1, 0 },
				{ __LINE__, 555.55555555,      "600 s ", 1, 0 },
				{ __LINE__, 5555.5555555,        "6 ks", 1, 0 },

				{ __LINE__, .00555555555,        "6 ms", 3, 0 },
				{ __LINE__, .05555555555,       "56 ms", 3, 0 },
				{ __LINE__, .55555555555,      "556 ms", 3, 0 },
				{ __LINE__, 5.5555555555,        "6 s ", 3, 0 },
				{ __LINE__, 55.555555555,       "56 s ", 3, 0 },
				{ __LINE__, 555.55555555,      "556 s ", 3, 0 },
				{ __LINE__, 5555.5555555,        "6 ks", 3, 0 },

				{ __LINE__, .00555555555,     "5556 us", 4, 0 },
				{ __LINE__, .05555555555,    "55560 us", 4, 0 },
				{ __LINE__, .55555555555,   "555600 us", 4, 0 },
				{ __LINE__, 5.5555555555,     "5556 ms", 4, 0 },
				{ __LINE__, 55.555555555,    "55560 ms", 4, 0 },
				{ __LINE__, 555.55555555,   "555600 ms", 4, 0 },
				{ __LINE__, 5555.5555555,     "5556 s ", 4, 0 },

				{ __LINE__, .00555555555,      "5.6 ms", 2, 1 },
				{ __LINE__, .05555555555,     "56.0 ms", 2, 1 },
				{ __LINE__, .55555555555,    "560.0 ms", 2, 1 },
				{ __LINE__, 5.5555555555,      "5.6 s ", 2, 1 },
				{ __LINE__, 55.555555555,     "56.0 s ", 2, 1 },
				{ __LINE__, 555.55555555,    "560.0 s ", 2, 1 },
				{ __LINE__, 5555.5555555,      "5.6 ks", 2, 1 },

				{ __LINE__, .00555555555,      "5.6 ms", 4, 1 },
				{ __LINE__, .05555555555,     "55.6 ms", 4, 1 },
				{ __LINE__, .55555555555,    "555.6 ms", 4, 1 },
				{ __LINE__, 5.5555555555,      "5.6 s ", 4, 1 },
				{ __LINE__, 55.555555555,     "55.6 s ", 4, 1 },
				{ __LINE__, 555.55555555,    "555.6 s ", 4, 1 },
				{ __LINE__, 5555.5555555,      "5.6 ks", 4, 1 },

				{ __LINE__, .00555555555,   "5555.6 us", 5, 1 },
				{ __LINE__, .05555555555,  "55556.0 us", 5, 1 },
				{ __LINE__, .55555555555, "555560.0 us", 5, 1 },
				{ __LINE__, 5.5555555555,   "5555.6 ms", 5, 1 },
				{ __LINE__, 55.555555555,  "55556.0 ms", 5, 1 },
				{ __LINE__, 555.55555555, "555560.0 ms", 5, 1 },
				{ __LINE__, 5555.5555555,   "5555.6 s ", 5, 1 },

				{ __LINE__, .00555555555,   "5555.56 us", 6, 2 },
				{ __LINE__, .05555555555,  "55555.60 us", 6, 2 },
				{ __LINE__, .55555555555, "555556.00 us", 6, 2 },
				{ __LINE__, 5.5555555555,   "5555.56 ms", 6, 2 },
				{ __LINE__, 55.555555555,  "55555.60 ms", 6, 2 },
				{ __LINE__, 555.55555555, "555556.00 ms", 6, 2 },
				{ __LINE__, 5555.5555555,   "5555.56 s ", 6, 2 },
			};

			for (auto &test : tests_set)
			{	const auto reality = misc::to_string(ch::duration<double>{ test.num_ }, test.significant_, test.decimal_);
				assert(reality == test.expected_);
			}
		}

		return 0;
	}();
}
#endif // #ifndef NDEBUG
