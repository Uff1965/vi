// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

/********************************************************************\
'vi_timing' is a compact and lightweight library for measuring code execution
time in C and C++. 

Copyright (C) 2025 A.Prograamar

This library was created for experimental and educational use. 
Please keep expectations reasonable. If you find bugs or have suggestions for 
improvement, contact programmer.amateur@proton.me.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. 
If not, see <https://www.gnu.org/licenses/gpl-3.0.html#license-text>.
\********************************************************************/

#include "build_number_maker.h"

#include <array>
#include <cassert>
#include <string_view>

namespace
{
	constexpr auto to_month(const char *str)
	{	// 7.27.3.1 The asctime function. [C17 ballot ISO/IEC 9899:2017]
		constexpr std::array<std::string_view, 13> month_names
		{	"", "Jan", "Feb", "Mar", "Apr", "May", "Jun",
			"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
		};
		auto month = month_names.size();
		while (0 != --month && 0 != month_names[month].compare(0, 3, str, 3))
		{/**/}
		assert(month);
		return static_cast<std::uint32_t>(month);
	}

	constexpr std::uint32_t c2d(char c)
	{	assert('0' <= c && c <= '9' || c == ' ');
		return c == ' ' ? 0U : c - '0';
	};

	constexpr auto to_num(const char *str)
	{	std::uint32_t result = 10U * c2d(*str);
		result += c2d(*++str);
		return result;
	};

	// The time_stamp function converts date and time strings in the __DATE__ and __TIME__ formats to
	// a number representing a timestamp in the YYMMDDhhmm format.
	constexpr std::uint32_t time_stamp(const char (&date)[12], const char (&time)[9])
	{	// "__DATE__ <...> a character string literal of the form 'Mmm dd yyyy'" [15.11 Predefined macro names ISO/IEC JTC1 SC22 WG21 N4860]
		assert(0 == date[11] && date[3] == ' ' && date[6] == ' ' && "The date must be in the __DATE__ macro format.");
		constexpr auto POSITION_DECADES = 9U;
		constexpr auto POSITION_MONTHS = 0U;
		constexpr auto POSITION_DATES = 4U;
		const auto year = to_num(&date[POSITION_DECADES]);
		assert(year < 43U); // Time coding up to 23:59 on Dec 31 2042 is permitted.
		const auto month = to_month(&date[POSITION_MONTHS]);
		const auto day = to_num(&date[POSITION_DATES]);

		// "__TIME__ <...> a character string literal of the form 'hh:mm:ss' as in the time generated by the asctime function."
		assert(0 == time[8] && time[2] == ':' && time[5] == ':' && "The time must be in the __TIME__ macro format.");
		constexpr auto POSITION_HOURS = 0U;
		constexpr auto POSITION_MINUTES = 3U;
		const auto hour = to_num(&time[POSITION_HOURS]);
		const auto minute = to_num(&time[POSITION_MINUTES]);

		return(100U * (100U * (100U * (100U * year + month) + day) + hour) + minute);
	}

#if	VI_TM_DEBUG // Nanotest for time_stamp() function.
	constexpr char sample_DATE_[] = "Jun 17 2025";
	constexpr char sample_TIME_[] = "09:33:00";
	static_assert(time_stamp(sample_DATE_, sample_TIME_) == 2506170933U, "time_stamp() is not working correctly.");
#endif

	std::uint32_t build_number = 0U; // build_number is initialized by the compilation time of the last unit of translation in the YYMMDDhhmm format.
}

std::uint32_t misc::build_number_updater(const char (&date)[12], const char (&time)[9])
{	build_number = std::max(time_stamp(date, time), build_number);
	return build_number;
}

std::uint32_t misc::build_number_get()
{	return build_number;
}
