// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

/********************************************************************\
'vi_timing' is a compact library designed for measuring the execution time of
code in C and C++.

Copyright (C) 2024 A.Prograamar

This library was developed for experimental and educational purposes.
Please temper your expectations accordingly. If you encounter any bugs or have
suggestions for improvements, kindly contact me at programmer.amateur@proton.me.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. 
If not, see <https://www.gnu.org/licenses/gpl-3.0.html#license-text>.
\********************************************************************/

#include "build_number_maker.h"

#include <array>
#include <cassert>
#include <string_view>

namespace
{

	// function time_stamp converts date and time strings into a single unsigned integer representing the timestamp in the format YYMMDDhhmm.
	constexpr unsigned time_stamp(const char (&date)[12], const char (&time)[9])
	{	assert(0 == date[11] && 0 == time[8]);
		// "__DATE__ <...> a character string literal of the form 'Mmm dd yyyy'" [15.11 Predefined macro names ISO/IEC JTC1 SC22 WG21 N4860]
		enum { M1 = 0, M2, M3, D1 = 4, D2, Y3 = 9, Y4}; //__DATE__ "Mmm dd yyyy"
		// "__TIME__ <...> a character string literal of the form 'hh:mm:ss' as in the time generated by the asctime function."
		enum { h1 = 0, h2, m1 = 3, m2, s1 = 6, s2}; //__TIME__ "hh:mm:ss"
		auto c2d = [](char c) { return c == ' ' ? 0 : c - '0'; };
		auto date_c = [c2d, date](std::size_t n) { return c2d(date[n]); };
		auto time_c = [c2d, time](std::size_t n) { return c2d(time[n]); };

		const unsigned year = date_c(Y3) * 10 + date_c(Y4);
		const unsigned month = [](const char *date)
			{	// 7.27.3.1 The asctime function. [C17 ballot ISO/IEC 9899:2017]
				constexpr std::array<std::string_view, 13> mon_names{"", "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
				auto n = mon_names.size();
				while (--n && std::string_view{ date, 3 } != mon_names[n])
				{/**/}
				return static_cast<unsigned>(n);
			}(date);
		const unsigned day = date_c(D1) * 10 + date_c(D2);
		const unsigned hour = time_c(h1) * 10 + time_c(h2);
		const unsigned minute = time_c(m1) * 10 + time_c(m2);

		return(100 * (100 * (100 * (100 * year + month) + day) + hour) + minute);
	}

	unsigned build_number = 0U; // build_number is initialized by the compilation time of the last unit of translation in the YYMMDDhhmm format.
}

unsigned misc::build_number_updater(const char (&date)[12], const char (&time)[9])
{	build_number = std::max(time_stamp(date, time), build_number);
	return build_number;
}

unsigned misc::build_number_get()
{	return build_number;
}
