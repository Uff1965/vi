// This is an independent project of an individual developer. Dear PVS-Studio, please check it.
// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: http://www.viva64.com

/********************************************************************\
'vi_timing' is a compact library designed for measuring the execution time of
code in C and C++.

Copyright (C) 2024 A.Prograamar

This library was developed for experimental and educational purposes.
Please temper your expectations accordingly. If you encounter any bugs or have
suggestions for improvements, kindly contact me at programmer.amateur@proton.me.

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. 
If not, see <https://www.gnu.org/licenses/gpl-3.0.html#license-text>.
\********************************************************************/

#include <vi_timing.h>

#if defined(_WIN32)
#	include <Windows.h>
#elif defined(__linux__)
#	include <time.h> // for clock_gettime
#endif

#if defined(_M_X64) || defined(_M_AMD64) // MSVC on x86-64
#	include <intrin.h>
#	pragma intrinsic(__rdtscp, _mm_lfence)
#elif defined(__x86_64__) || defined(__amd64__) // GCC on x86_64
#	include <x86intrin.h>
#endif

#include <array>
#include <atomic>
#include <cassert>
#include <cstring>
#include <mutex>
#include <string>
#include <unordered_map> // Unordered associative containers: "Rehashing invalidates iterators, <...> but does not invalidate pointers or references to elements".

#ifdef __STDC_NO_ATOMICS__
//	At the moment Atomics are available in Visual Studio 2022 with the /experimental:c11atomics flag.
//	"we left out support for some C11 optional features such as atomics" [Microsoft
//	https://devblogs.microsoft.com/cppblog/c11-atomics-in-visual-studio-2022-version-17-5-preview-2]
#	error "Atomic objects and the atomic operation library are not supported."
#endif

namespace
{
#ifdef NDEBUG
	constexpr char CONFIG[] = "Release";
#else
	constexpr char CONFIG[] = "Debug";
#endif
#ifdef VI_TM_SHARED
	constexpr char TYPE[] = "shared";
#else
	constexpr char TYPE[] = "static";
#endif

// Definition of vi_tmGetTicks() function for different platforms. vvvvvvvvvvvv
#if defined(_M_X64) || defined(_M_AMD64) || defined(__x86_64__) || defined(__amd64__) // MSC or GCC on Intel
	inline vi_tmTicks_t vi_tmGetTicks(void) noexcept
	{	std::uint32_t _; // Will be removed by the optimizer.
		const std::uint64_t result = __rdtscp(&_);
		//	«If software requires RDTSCP to be executed prior to execution of any subsequent instruction 
		//	(including any memory accesses), it can execute LFENCE immediately after RDTSCP» - 
		//	(Intel® 64 and IA-32 Architectures Software Developer’s Manual Combined Volumes:
		//	1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D, and 4. Vol. 2B. P.4-553)
		_mm_lfence();
		return result;
	}
#elif __ARM_ARCH >= 8 // ARMv8 (RaspberryPi4)
	inline vi_tmTicks_t vi_tmGetTicks(void) noexcept
	{	std::uint64_t result;
		__asm__ __volatile__("mrs %0, cntvct_el0" : "=r"(result));
		return result;
	}
#elif defined(_WIN32) // Windows
	inline vi_tmTicks_t vi_tmGetTicks(void) noexcept
	{	LARGE_INTEGER cnt;
		QueryPerformanceCounter(&cnt);
		return cnt.QuadPart;
	}
#elif defined(__linux__)
	inline vi_tmTicks_t vi_tmGetTicks(void) noexcept
	{	struct timespec ts;
		clock_gettime(CLOCK_MONOTONIC_RAW, &ts);
		return 1'000'000'000U * ts.tv_sec + ts.tv_nsec;
	}
#else
#	error "You need to define function(s) for your OS and CPU"
#endif
// Definition of vi_tmGetTicks() function for different platforms. ^^^^^^^^^^^^

	constexpr unsigned TIME_STAMP()
	{	// 7.27.3.1 The asctime function. [C17 ballot ISO/IEC 9899:2017]
		constexpr std::array<std::string_view, 12> mon_names{"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
		// "__DATE__ <...> a character string literal of the form 'Mmm dd yyyy'" [15.11 Predefined macro names ISO/IEC JTC1 SC22 WG21 N4860]
		enum { M1 = 0, M2, M3, D1 = 4, D2, Y3 = 9, Y4}; //__DATE__ "Mmm dd yyyy"
		// "__TIME__ <...> a character string literal of the form 'hh:mm:ss' as in the time generated by the asctime function."
		enum { h1 = 0, h2, m1 = 3, m2, s1 = 6, s2}; //__TIME__ "hh:mm:ss"
		auto c2d = [](char c) { return c == ' ' ? 0 : c - '0'; };
		auto date_c = [c2d](std::size_t n) { return c2d(__DATE__[n]); };
		auto time_c = [c2d](std::size_t n) { return c2d(__TIME__[n]); };
		
		unsigned result = 0U;
		result += date_c(Y3) * 10 + date_c(Y4);

		result *= 100;
		for (unsigned n = 0; n < mon_names.size(); ++n)
		{	if (std::string_view{ __DATE__, 3 } == mon_names[n])
			{	result += n + 1;
				break;
			}
		}

		result *= 100;
		result += date_c(D1) * 10 + date_c(D2);

		result *= 100;
		result += time_c(h1) * 10 + time_c(h2);

		result *= 100;
		result += time_c(m1) * 10 + time_c(m2);

		return result;
	}

	struct item_t
	{	vi_tmTicks_t total_ = 0U;
		std::size_t counter_ = 0U;
		std::size_t calls_cnt_ = 0U;
		void add(vi_tmTicks_t ticks, std::size_t amount) noexcept
		{	total_ += ticks;
			counter_ += amount;
			++calls_cnt_;
		}
		void clear() noexcept
		{	total_ = counter_ = calls_cnt_ = 0U;
		};
	};

	constexpr auto MAX_LOAD_FACTOR = 0.7F;
	constexpr std::size_t STORAGE_CAPACITY = 64U;
	using storage_t = std::unordered_map<std::string, item_t>;
} // namespace

struct vi_tmInstance_t
{	std::mutex storage_guard_;
	storage_t storage_;

	explicit vi_tmInstance_t()
	{	storage_.max_load_factor(MAX_LOAD_FACTOR);
		storage_.reserve(STORAGE_CAPACITY);
	}

	static vi_tmInstance_t& global()
	{	static vi_tmInstance_t inst;
		return inst;
	}

	int init()
	{	return 0;
	}

	void add(const char *name, vi_tmTicks_t ticks, std::size_t amount) noexcept
	{	std::lock_guard lock{ storage_guard_ };
		storage_[name].add(ticks, amount);
	}

	int result(const char *name, vi_tmTicks_t *time, std::size_t *amount, std::size_t *calls_cnt)
	{	std::lock_guard lock{ storage_guard_ };

		if (auto it = storage_.find(name); it != storage_.end())
		{	assert(it->first == name);
			if (time) { *time = it->second.total_; }
			if (amount) { *amount = it->second.counter_; }
			if (calls_cnt) { *calls_cnt = it->second.calls_cnt_; }

			return 1;
		}

		if (time) { *time = 0; }
		if (amount) { *amount = 0; }
		if (calls_cnt) { *calls_cnt = 0; }

		return 0;
	}

	int results(vi_tmLogRAW_t fn, void *data)
	{	std::lock_guard lock{ storage_guard_ };

		for (const auto &[name, item] : storage_)
		{	assert(item.counter_ >= item.calls_cnt_ && ((0 == item.total_) == (0 == item.calls_cnt_)));
			if (!name.empty() && 0 == fn(name.c_str(), item.total_, item.counter_, item.calls_cnt_, data))
			{	return 0;
			}
		}
		return -1;
	}
	
	void clear(const char *name = nullptr)
	{	std::lock_guard lock{ storage_guard_ };

		if (!name)
		{	for (auto &[_, item] : storage_)
			{	item.clear();
			}
		}
		else if (const auto [it, b] = storage_.try_emplace(name); !b)
		{	it->second.clear();
		}
	}

	friend vi_tmInstance_t& from_handle(VI_TM_HANDLE h)
	{	return h? *h: global();
	}
}; // struct vi_tmInstance_t

//vvvv API Implementation vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

int VI_TM_CALL vi_tmInit()
{	return vi_tmInstance_t::global().init();
}

void VI_TM_CALL vi_tmFinit(void)
{	vi_tmInstance_t::global().clear();
}

VI_TM_HANDLE VI_TM_CALL vi_tmCreate()
{	return new vi_tmInstance_t{};
}

void VI_TM_CALL vi_tmClose(VI_TM_HANDLE h)
{	delete h;
}

vi_tmTicks_t VI_TM_CALL vi_tmClock() noexcept
{	return vi_tmGetTicks();
}

void VI_TM_CALL vi_tmAppend(VI_TM_HANDLE h, const char *name, vi_tmTicks_t ticks, std::size_t amount) noexcept
{	from_handle(h).add(name, ticks, amount);
}

void VI_TM_CALL vi_tmClear(VI_TM_HANDLE h, const char* name) noexcept
{	from_handle(h).clear(name);
}

int VI_TM_CALL vi_tmResults(VI_TM_HANDLE h, vi_tmLogRAW_t fn, void *data)
{	return from_handle(h).results(fn, data);
}

int VI_TM_CALL vi_tmResult
(	VI_TM_HANDLE h,
	const char *name,
	vi_tmTicks_t *time,
	std::size_t *amount,
	std::size_t *calls_cnt
)
{	return from_handle(h).result(name, time, amount, calls_cnt);
}

std::uintptr_t VI_TM_CALL vi_tmInfo(vi_tmInfo_e info)
{	std::uintptr_t result = 0U;
	switch (info)
	{
		case VI_TM_INFO_VER:
		{	result = VI_TM_VERSION;
		} break;

		case VI_TM_INFO_BUILDNUMBER:
		{	result = TIME_STAMP(); //-V101 "Implicit assignment type conversion to memsize type."
		} break;

		case VI_TM_INFO_VERSION:
		{	static const auto version = []
				{	static_assert(VI_TM_VERSION_MAJOR <= 99 && VI_TM_VERSION_MINOR <= 999 && VI_TM_VERSION_PATCH <= 9999); //-V590 "Possible excessive expression or typo."
					std::array<char, std::size("99.999.9999.YYMMDDHHmmC ") - 1 + std::size(TYPE) - 1 + 1> res; //-V1065
					const auto sz = snprintf(res.data(), res.size(), VI_TM_VERSION_STR ".%u%c %s", TIME_STAMP(), CONFIG[0], TYPE);
					assert(0 < sz && sz < res.size()); //-V104 "Implicit type conversion to memsize type in an arithmetic expression."
					return res;
				}();
			result = reinterpret_cast<std::uintptr_t>(version.data());
		} break;

		case VI_TM_INFO_BUILDTYPE:
		{	result = reinterpret_cast<std::uintptr_t>(CONFIG);
		} break;

		default:
		{	assert(false);
		} break;
	}
	return result;
}

//^^^API Implementation ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
